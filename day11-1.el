;; -*- lexical-binding: t; -*-

;; In this file, columns and lines are presumed to begin at 0 (line 0 exists and is emacs line 1).
;; This is to simply processing.

(cl-defun forward-line-preserve-column (&optional (arg 1) &aux (column (current-column)))
  (if (or (/= (forward-line arg) 0) (eobp))
      nil
    (move-to-column column) t))

(cl-defun col-and-line-at-pos-zero-indexed (&optional (pos (point)))
  (save-excursion (goto-char pos)
                  (cons (current-column) (1- (line-number-at-pos)))))

(cl-defun buffer-dimensions (&optional (buffer (current-buffer)))
  (with-current-buffer buffer
    (save-excursion
      (goto-char (point-max))
      ; If we're at the beginning of the line, we're in the empty line
      ; generated by saving.
      (when (bolp) (forward-char -1))
      (cons (current-column) (line-number-at-pos)))))

(cl-defun galaxies-in-line? (line)
  (save-excursion (goto-char (point-min))
                  (beginning-of-line (1+ line))
                  (search-forward "#" (line-end-position) t)))

(cl-defun galaxies-in-column? (column)
  (save-excursion (goto-char (point-min))
                  (move-to-column column)
                  (cl-loop if (= (char-after) ?#)
                           return t
                           while (forward-line-preserve-column 1))))

(defun combinations (initial-list)
  (named-let all-combinations ((list-to-process initial-list)
                               (current-list nil))
    (if list-to-process
        (all-combinations (cdr list-to-process) (append current-list (cl-loop with first-item = (car list-to-process)
                                                                             for second-item in (cdr list-to-process)
                                                                             collect (cons first-item second-item))))
      current-list)))

(defun all-galaxies ()
  (save-excursion (goto-char (point-min))
                  (cl-loop while (search-forward "#" nil t)
                           collect (1- (point)))))

(defun distance-between-galaxies (galaxy1 galaxy2 expanded-lines expanded-columns)
  (pcase-let* ((`(,x-galaxy1 . ,y-galaxy1) (col-and-line-at-pos-zero-indexed galaxy1))
               (`(,x-galaxy2 . ,y-galaxy2) (col-and-line-at-pos-zero-indexed galaxy2))
               (x-expanded (--count (between? x-galaxy1 x-galaxy2 it) expanded-columns))
               (y-expanded (--count (between? y-galaxy1 y-galaxy2 it) expanded-lines))
               (x-distance (+ (abs (- x-galaxy1 x-galaxy2)) x-expanded))
               (y-distance (+ (abs (- y-galaxy1 y-galaxy2)) y-expanded)))
    (+ x-distance y-distance)))

(cl-defun between? (bound1 bound2 number)
  (let ((highest-bound (max bound1 bound2))
        (lowest-bound (min bound1 bound2)))
    (< lowest-bound number highest-bound)))

(with-current-buffer "input.txt"
  (let* ((dimensions (buffer-dimensions))
         (expanded-columns (cl-loop for current-column from 0 below (car dimensions)
                                    unless (galaxies-in-column? current-column)
                                    collect current-column))
         (expanded-lines (cl-loop for current-line from 0 below (cdr dimensions)
                          unless (galaxies-in-line? current-line)
                          collect current-line))
         (galaxies (all-galaxies))
         (galaxy-combinations (combinations galaxies)))
    (cl-loop for galaxy-combination in galaxy-combinations
             sum (distance-between-galaxies (car galaxy-combination) (cdr galaxy-combination) expanded-lines expanded-columns))))
